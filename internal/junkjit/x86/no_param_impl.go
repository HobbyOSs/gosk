// Code generated by go generate; DO NOT EDIT.
package x86

import (
	"github.com/HobbyOSs/gosk/internal/asmdb"

	"encoding/hex"
	"fmt"
)

func (a *X86Assembler) AAA() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("AAA")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) AAD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("AAD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) AAM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("AAM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) AAS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("AAS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) ADX() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("ADX")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) ALTER() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("ALTER")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) AMX() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("AMX")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CBW() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CBW")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CDQ() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CDQ")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CDQE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CDQE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CLC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CLC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CLD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CLD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CLI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CLI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CLTS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CLTS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CMC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CMC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CPUID() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CPUID")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CQO() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CQO")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CWD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CWD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) CWDE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("CWDE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) DAA() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("DAA")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) DAS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("DAS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) DIV() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("DIV")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) DS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("DS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) EMMS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("EMMS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) ENTER() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("ENTER")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) ES() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("ES")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) F2XM1() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("F2XM1")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FABS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FABS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FADDP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FADDP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FCHS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FCHS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FCLEX() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FCLEX")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FCOM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FCOM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FCOMP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FCOMP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FCOMPP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FCOMPP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FCOS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FCOS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FDECSTP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FDECSTP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FDISI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FDISI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FDIVP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FDIVP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FDIVRP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FDIVRP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FENI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FENI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FINCSTP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FINCSTP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FINIT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FINIT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLD1() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLD1")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLDL2E() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLDL2E")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLDL2T() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLDL2T")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLDLG2() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLDLG2")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLDLN2() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLDLN2")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLDPI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLDPI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FLDZ() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FLDZ")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FMULP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FMULP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FNCLEX() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FNCLEX")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FNDISI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FNDISI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FNENI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FNENI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FNINIT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FNINIT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FNOP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FNOP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FNSETPM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FNSETPM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FPATAN() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FPATAN")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FPREM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FPREM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FPREM1() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FPREM1")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FPTAN() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FPTAN")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FRNDINT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FRNDINT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FRSTOR() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FRSTOR")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSCALE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSCALE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSETPM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSETPM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSIN() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSIN")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSINCOS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSINCOS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSQRT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSQRT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSUBP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSUBP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FSUBRP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FSUBRP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FTST() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FTST")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FUCOM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FUCOM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FUCOMP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FUCOMP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FUCOMPP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FUCOMPP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FXAM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FXAM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FXCH() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FXCH")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FXRSTOR() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FXRSTOR")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FXTRACT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FXTRACT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FYL2X() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FYL2X")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) FYL2XP1() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("FYL2XP1")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) GETSEC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("GETSEC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) GS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("GS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) HLT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("HLT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) ICEBP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("ICEBP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) IDIV() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("IDIV")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) IMUL() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("IMUL")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) INTO() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("INTO")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) INVD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("INVD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) IRET() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("IRET")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) IRETD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("IRETD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) IRETQ() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("IRETQ")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) JMPE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("JMPE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) LAHF() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("LAHF")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) LEAVE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("LEAVE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) LFENCE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("LFENCE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) LOADALL() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("LOADALL")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) LOCK() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("LOCK")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) MFENCE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("MFENCE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) MONITOR() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("MONITOR")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) MUL() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("MUL")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) MWAIT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("MWAIT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) NOP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("NOP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) NTAKEN() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("NTAKEN")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) PAUSE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("PAUSE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) POPA() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("POPA")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) POPAD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("POPAD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) POPF() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("POPF")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) POPFD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("POPFD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) POPFQ() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("POPFQ")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) PUSHA() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("PUSHA")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) PUSHAD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("PUSHAD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) PUSHF() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("PUSHF")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) PUSHFD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("PUSHFD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) PUSHFQ() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("PUSHFQ")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RDMSR() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RDMSR")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RDPMC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RDPMC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RDTSC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RDTSC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RDTSCP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RDTSCP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) REP() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("REP")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) REPE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("REPE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) REPNE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("REPNE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RETF() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RETF")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RETN() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RETN")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) RSM() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("RSM")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SAHF() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SAHF")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SETALC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SETALC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SFENCE() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SFENCE")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) STC() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("STC")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) STD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("STD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) STI() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("STI")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SWAPGS() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SWAPGS")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SYSCALL() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SYSCALL")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SYSENTER() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SYSENTER")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SYSEXIT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SYSEXIT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) SYSRET() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("SYSRET")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) TAKEN() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("TAKEN")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) UD2() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("UD2")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) VMCALL() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("VMCALL")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) VMLAUNCH() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("VMLAUNCH")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) VMRESUME() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("VMRESUME")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) VMXOFF() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("VMXOFF")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) WAIT() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("WAIT")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) WBINVD() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("WBINVD")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) WRMSR() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("WRMSR")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) XGETBV() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("XGETBV")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) XRSTOR() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("XRSTOR")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}

func (a *X86Assembler) XSETBV() int {
	ref := asmdb.X86Reference()
	opcode := ref.InstructionsBy("XSETBV")[0].Opcode
	bytes, err := hex.DecodeString(opcode)
	if err != nil {
		panic(fmt.Sprintf("Error converting hex string to bytes: %v", err))
	}
	a.Code.Bytes = append(a.Code.Bytes, bytes...)
	return 1
}
