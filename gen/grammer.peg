{
package gen

import (
    "github.com/morikuni/failure"
    "github.com/hangingman/gosk/ast"
    "github.com/harakeishi/gats"
)

func toAnySlice(v any) []any {
    if v == nil {
        return nil
    }
    return v.([]any)
}

func parseError() error {
	return failure.New(ParseError,
		//failure.Context{"hoge": "fuga"},
		failure.Message("Parse error"),
	)
}

const (
	ParseError failure.StringCode = "ParseError"
)

}

Program <- list:(Statement TrailingWsEOL)* END {
    statements := make([]ast.Statement, 0)
    for _, anySlice := range toAnySlice(list) {
        tuple := toAnySlice(anySlice)
        if tuple == nil {
            return nil, parseError()
        }
        stmt, ok := tuple[0].(ast.Statement)
        if !ok {
            return nil, parseError()
        }
        statements = append(statements, stmt)
    }
    return ast.NewProgram(statements), parseError()
}

Statement <- LabelStmt /
    DeclareStmt /
    ExportSymStmt /
    ExternSymStmt /
    ConfigStmt /
    MnemonicStmt

LabelStmt <- l:Label {
    label, ok := l.(string)
    if !ok {
        return nil, parseError()
    }
    return ast.NewLabelStmt(ast.BaseStatement{}, ast.NewIdentFactor(ast.BaseFactor{}, label)), nil
}

Label <- !ReservedWord [a-zA-Z$_.] ([a-zA-Z$_.0-9])* ':' &( TrailingWsEOL ) {
    return string(c.text), nil
}

DeclareStmt <- f:IdentFactor _ "EQU" _ e:Exp {
    factor, ok := f.(*ast.IdentFactor)
    if !ok {
        return nil, parseError()
    }
    exp, ok := e.(ast.Exp)
    if !ok {
        return nil, parseError()
    }
    return ast.NewDeclareStmt(ast.BaseStatement{}, factor, exp), nil
}

ExportSymStmt <- "GLOBAL" _ head:IdentFactor _ tail:(_ ',' _ IdentFactor)*  {
    factors := make([]*ast.IdentFactor, 0)
    f, ok := head.(*ast.IdentFactor)
    if !ok {
        return nil, parseError()
    }
    factors = append(factors, f)

    for _, anySlice := range toAnySlice(tail) {
        tuple := toAnySlice(anySlice)
        if tuple == nil {
            return nil, parseError()
        }
        f, ok := tuple[3].(*ast.IdentFactor)
        if ! ok {
            return nil, parseError()
        }
        factors = append(factors, f)
    }

    return ast.NewExportSymStmt(ast.BaseStatement{}, factors), nil
}

ExternSymStmt <- "EXTERN" _ head:IdentFactor _ tail:(_ ',' _ IdentFactor)*  {
    factors := make([]*ast.IdentFactor, 0)
    f, ok := head.(*ast.IdentFactor)
    if !ok {
        return nil, parseError()
    }
    factors = append(factors, f)

    for _, anySlice := range toAnySlice(tail) {
        tuple := toAnySlice(anySlice)
        if tuple == nil {
            return nil, parseError()
        }
        f, ok := tuple[3].(*ast.IdentFactor)
        if ! ok {
            return nil, parseError()
        }
        factors = append(factors, f)
    }

    return ast.NewExternSymStmt(ast.BaseStatement{}, factors), nil
}

ConfigStmt <- config:ConfigType _ f:Factor ']' {
    configType, ok := config.(ast.ConfigType)
    if !ok {
        return nil, parseError()
    }
    factor, ok := f.(ast.Factor)
    if !ok {
        return nil, parseError()
    }
    return ast.NewConfigStmt(ast.BaseStatement{}, configType, factor), nil
}

ConfigType <- '[' conf:Conf &(_ Factor ']') {
    config, err := gats.ToString(conf)
    if err != nil {
        return nil, failure.Wrap(err)
    }
    configType, ok := ast.NewConfigType(config)
    if !ok {
        return nil, parseError()
    }

    return configType, nil
}

Conf = "BITS" / "INSTRSET" / "OPTIMIZE" / "FORMAT" / "PADDING" / "PADSET" / "SECTION" / "ABSOLUTE" / "FILE" ;

MnemonicStmt <- _ o:Opcode _ head:Operand _ tail:(',' Operand)+ {
    opcodeStr, err := gats.ToString(o)
    if err != nil {
        return nil, failure.Wrap(err)
    }
    opcode := ast.NewIdentFactor(ast.BaseFactor{}, opcodeStr)

    operands := make([]ast.Exp, 0)
    e, ok := head.(ast.Exp)
    if !ok {
        return nil, parseError()
    }
    operands = append(operands, e)

    for _, anySlice := range toAnySlice(tail) {
        tuple := toAnySlice(anySlice)
        if tuple == nil {
            return nil, parseError()
        }
        exp, ok := tuple[1].(ast.Exp)
        if !ok {
            return nil, parseError()
        }
        operands = append(operands, exp)
    }

    return ast.NewMnemonicStmt(ast.BaseStatement{}, opcode, operands), nil
}

Operand <- Exp

Opcode = "AAA" / "AAD" / "AAS" / "AAM" / "ADC" / "ADD" / "AND" / "ALIGN" / "ALIGNB" /
    "ARPL" / "BOUND" / "BSF" / "BSR" / "BSWAP" / "BT" / "BTC" / "BTR" / "BTS" /
    "CALL" / "CBW" / "CDQ" / "CLC" / "CLD" / "CLI" / "CLTS" / "CMC" / "CMP" /
    "CMPSB" / "CMPSD" / "CMPSW" / "CMPXCHG" / "CPUID" / "CWD" / "CWDE" / "DAA" /
    "DAS" / "DB" / "DD" / "DEC" / "DIV" / "DQ" / "DT" / "DW" / "END" / "ENTER" /
    "F2XM1" / "FABS" / "FADD" / "FADDP" / "FBLD" / "FBSTP" / "FCHS" / "FCLEX" /
    "FCOM" / "FCOMP" / "FCOMPP" / "FCOS" / "FDECSTP" / "FDISI" / "FDIV" / "FDIVP" /
    "FDIVR" / "FDIVRP" / "FENI" / "FFREE" / "FIADD" / "FICOM" / "FICOMP" / "FIDIV" /
    "FIDIVR" / "FILD" / "FIMUL" / "FINCSTP" / "FINIT" / "FIST" / "FISTP" / "FISUB" /
    "FISUBR" / "FLD" / "FLD1" / "FLDCW" / "FLDENV" / "FLDL2E" / "FLDL2T" / "FLDLG2" /
    "FLDLN2" / "FLDPI" / "FLDZ" / "FMUL" / "FMULP" / "FNCLEX" / "FNDISI" / "FNENI" /
    "FNINIT" / "FNOP" / "FNSAVE" / "FNSTCW" / "FNSTENV" / "FNSTSW" / "FPATAN" /
    "FPTAN" / "FPREM" / "FPREM1" / "FRNDINT" / "FRSTOR" / "FSAVE" / "FSCALE" /
    "FSETPM" / "FSIN" / "FSINCOS" / "FSQRT" / "FST" / "FSTCW" / "FSTENV" / "FSTP" /
    "FSTSW" / "FSUB" / "FSUBP" / "FSUBR" / "FSUBRP" / "FTST" / "FUCOM" / "FUCOMP" /
    "FUCOMPP" / "FXAM" / "FXCH" / "FXTRACT" / "FYL2X" / "FYL2XP1" / "HLT" / "IDIV" /
    "IMUL" / "IN" / "INC" / "INCO" / "INSB" / "INSD" / "INSW" / "INT" / "INT3" /
    "INTO" / "INVD" / "INVLPG" / "IRET" / "IRETD" / "IRETW" / "JA" / "JAE" / "JB" /
    "JBE" / "JC" / "JCXZ" / "JE" / "JECXZ" / "JG" / "JGE" / "JL" / "JLE" / "JMP" /
    "JNA" / "JNAE" / "JNB" / "JNBE" / "JNC" / "JNE" / "JNG" / "JNGE" / "JNL" /
    "JNLE" / "JNO" / "JNP" / "JNS" / "JNZ" / "JO" / "JP" / "JPE" / "JPO" / "JS" /
    "JZ" / "LAHF" / "LAR" / "LDS" / "LEA" / "LEAVE" / "LES" / "LFS" / "LGDT" / "LGS" /
    "LIDT" / "LLDT" / "LMSW" / "LOCK" / "LODSB" / "LODSD" / "LODSW" / "LOOP" /
    "LOOPE" / "LOOPNE" / "LOOPNZ" / "LOOPZ" / "LSL" / "LSS" / "LTR" / "MOV" /
    "MOVSB" / "MOVSD" / "MOVSW" / "MOVSX" / "MOVZX" / "MUL" / "NEG" / "NOP" / "NOT" /
    "OR" / "ORG" / "OUT" / "OUTSB" / "OUTSD" / "OUTSW" / "POP" / "POPA" / "POPAD" /
    "POPAW" / "POPF" / "POPFD" / "POPFW" / "PUSH" / "PUSHA" / "PUSHD" / "PUSHAD" /
    "PUSHAW" / "PUSHF" / "PUSHFD" / "PUSHFW" / "RCL" / "RCR" / "RDMSR" / "RDPMC" /
    "REP" / "REPE" / "REPNE" / "REPNZ" / "REPZ" / "RESB" / "RESD" / "RESQ" / "REST" /
    "RESW" / "RET" / "RETF" / "RETN" / "ROL" / "ROR" / "RSM" / "SAHF" / "SAL" /
    "SAR" / "SBB" / "SCASB" / "SCASD" / "SCASW" / "SETA" / "SETAE" / "SETB" /
    "SETBE" / "SETC" / "SETE" / "SETG" / "SETGE" / "SETL" / "SETLE" / "SETNA" /
    "SETNAE" / "SETNB" / "SETNBE" / "SETNC" / "SETNE" / "SETNG" / "SETNGE" / "SETNL" /
    "SETNLE" / "SETNO" / "SETNP" / "SETNS" / "SETNZ" / "SETO" / "SETP" / "SETPE" /
    "SETPO" / "SETS" / "SETZ" / "SGDT" / "SHL" / "SHLD" / "SHR" / "SHRD" / "SIDT" /
    "SLDT" / "SMSW" / "STC" / "STD" / "STI" / "STOSB" / "STOSD" / "STOSW" / "STR" /
    "SUB" / "TEST" / "TIMES" / "UD2" / "VERR" / "VERW" / "WAIT" / "WBINVD" / "WRMSR" /
    "XADD" / "XCHG" / "XLATB" / "XOR" ;

DataType = "BYTE" / "WORD" / "DWORD" ;

Exp <- MemoryAddrExp / SegmentExp

MemoryAddrExp <- _ d:DataType? _ '[' _ l:AddExp r:(':' AddExp)? ']' {
    var dt ast.DataType
    if dts, err := gats.ToString(d); err == nil {
        dt, _ = ast.NewDataType(dts)
    }
    left, ok := l.(*ast.AddExp)
    if !ok {
        return nil, parseError()
    }
    tuple := toAnySlice(r)
    if tuple == nil || tuple[1] == nil {
        return ast.NewMemoryAddrExp(ast.BaseExp{}, dt, left, nil), nil
    }
    right, ok := tuple[1].(*ast.AddExp)
    if !ok {
        return ast.NewMemoryAddrExp(ast.BaseExp{}, dt,left, nil), nil
    }

    return ast.NewMemoryAddrExp(ast.BaseExp{}, dt, left, right), nil
}

SegmentExp <- _ d:DataType? _ l:AddExp r:(':' AddExp)? {
    var dt ast.DataType
    if dts, err := gats.ToString(d); err == nil {
        dt, _ = ast.NewDataType(dts)
    }
    left, ok := l.(*ast.AddExp)
    if !ok {
        return nil, parseError()
    }
    tuple := toAnySlice(r)
    if tuple == nil || tuple[1] == nil {
        return ast.NewSegmentExp(ast.BaseExp{}, dt, left, nil), nil
    }
    right, ok := tuple[1].(*ast.AddExp)
    if !ok {
        return ast.NewSegmentExp(ast.BaseExp{}, dt,left, nil), nil
    }

    return ast.NewSegmentExp(ast.BaseExp{}, dt, left, right), nil
}

AddExp <- head:MultExp tail:(('+' / '-') MultExp)* {
    mult, ok := head.(*ast.MultExp)
    if !ok {
        return nil, parseError()
    }

    ops := make([]string, 0)
    exps := make([]*ast.MultExp, 0)

    for _, anySlice := range toAnySlice(tail) {
        tuple := toAnySlice(anySlice)
        if tuple == nil {
            return nil, parseError()
        }
        op, err := gats.ToString(tuple[0])
        if err != nil {
            return nil, failure.Wrap(err)
        }
        ops = append(ops, op)

        exp, ok := tuple[1].(*ast.MultExp)
        if !ok {
            return nil, parseError()
        }
        exps = append(exps, exp)
    }
    return ast.NewAddExp(ast.BaseExp{}, mult, ops, exps), nil
}

MultExp <- head:ImmExp tail:(('*' / '/' / '%') ImmExp)* {
    imm, ok := head.(*ast.ImmExp)
    if !ok {
        return nil, parseError()
    }

    ops := make([]string, 0)
    exps := make([]*ast.ImmExp, 0)

    for _, anySlice := range toAnySlice(tail) {
        tuple := toAnySlice(anySlice)
        if tuple == nil {
            return nil, parseError()
        }
        op, err := gats.ToString(tuple[0])
        if err != nil {
            return nil, failure.Wrap(err)
        }
        ops = append(ops, op)

        exp, ok := tuple[1].(*ast.ImmExp)
        if !ok {
            return nil, parseError()
        }
        exps = append(exps, exp)
    }
    return ast.NewMultExp(ast.BaseExp{}, imm, ops, exps), nil
}

ImmExp <- f:Factor {
    factor, ok := f.(ast.Factor)
    if !ok {
        return nil, parseError()
    }
    return ast.NewImmExp(ast.BaseExp{}, factor), nil
}

Factor <- ConfigType /
    HexFactor /
    NumberFactor /
    IdentFactor /
    StringFactor /
    CharFactor

ReservedWord = "EQU" / "GLOBAL" / "EXTERN" ;

IdentFactor <- !ReservedWord [a-zA-Z$_.] ([a-zA-Z$_.0-9])* {
    return ast.NewIdentFactor(ast.BaseFactor{}, string(c.text)), nil
}

HexFactor <- '0' ('x' / 'X') ([0-9] / ["abcdef"] / ["ABCDEF"])+ {
    return ast.NewHexFactor(ast.BaseFactor{}, string(c.text)), nil
}

StringFactor <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    text, err := strconv.Unquote(string(c.text))
    if err != nil {
        return nil, failure.Wrap(err)
    }
    return ast.NewStringFactor(ast.BaseFactor{}, text), nil
}

EscapedChar ← [\x00-\x1f"\\]
EscapeSequence ← SingleCharEscape / UnicodeEscape

CharFactor <- '\'' (NormalChar / SingleCharEscape)* '\'' {
    charSeq := string(c.text)
    return ast.NewCharFactor(ast.BaseFactor{}, charSeq[1 : len(charSeq) - 1]), nil
}
NormalChar <- [^'\\]  // シングルクォートとバックスラッシュ以外の任意の文字
SingleCharEscape <- '\\' [''\\/bfnrt']  // エスケープされた文字

NumberFactor <- '-'? [0-9]+ {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, failure.Wrap(err)
    }
    return ast.NewNumberFactor(ast.BaseFactor{}, val), nil
}

Comment <- ('#' / ';') Char* END {
    return "", nil
}

Char <- [^\n\r]

_ <- [ \n\t\r]*
__ <- [ \n\t\r]+

TrailingWsEOL <- [ \t]* EOL+

END <- EOL / EOF

EOL <- '\n' / '\r' / "\r\n"

EOF <- !.
