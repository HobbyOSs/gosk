{
package gen


import (
	"github.com/hangingman/gosk/ast"
)

func toAnySlice(v any) []any {
	if v == nil {
		return nil
	}
	return v.([]any)
}

}

Program <- _ list:(Statement)* _ {
    statements := make([]*ast.Statement, 0)
    for _, s := range toAnySlice(list) {
        stmt, ok := s.(*ast.Statement)
        if ! ok {
            return nil, nil
        }
        statements = append(statements, stmt)
    }
    return statements, nil
}

Statement <- LabelStmt / DeclareStmt / ExportSymStmt / ExternSymStmt / ConfigStmt / MnemonicStmt / OpcodeStmt

LabelStmt <- l:Label {
    label, ok := l.(string)
    if !ok {
        return nil, nil
    }
    return ast.NewLabelStmt(ast.BaseStatement{}, ast.NewIdentFactor(ast.BaseFactor{}, label)), nil
}

DeclareStmt <- f:IdentFactor _ "EQU" _ e:Exp {
    factor, ok := f.(*ast.IdentFactor)
    if !ok {
        return nil, nil
    }
    exp, ok := e.(ast.Exp)
    if !ok {
        return nil, nil
    }
    return ast.NewDeclareStmt(ast.BaseStatement{}, factor, exp), nil
}

Exp <- ImmExp

ImmExp <- f:Factor {
    factor, ok := f.(ast.Factor)
    if !ok {
        return nil, nil
    }
    return ast.NewImmExp(ast.BaseExp{}, factor), nil
}

Factor <- HexFactor / NumberFactor / IdentFactor / StringFactor / CharFactor

ReservedWord = "EQU" ;

IdentFactor <- !ReservedWord [a-zA-Z$_.] ([a-zA-Z$_.0-9])* {
    return ast.NewIdentFactor(ast.BaseFactor{}, string(c.text)), nil
}

Label <- !ReservedWord [a-zA-Z$_.] ([a-zA-Z$_.0-9])* ':' &(_) {
    return string(c.text), nil
}

HexFactor <- '0' ('x' / 'X') ([0-9] / ["abcdef"] / ["ABCDEF"])+ {
    return ast.NewHexFactor(ast.BaseFactor{}, string(c.text)), nil
}

StringFactor <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    text, err := strconv.Unquote(string(c.text))
    if err != nil {
        return nil, nil
    }
    return ast.NewStringFactor(ast.BaseFactor{}, text), nil
}

EscapedChar ← [\x00-\x1f"\\]
EscapeSequence ← SingleCharEscape / UnicodeEscape

CharFactor <- '\'' (NormalChar / SingleCharEscape)* '\'' {
    charSeq := string(c.text)
    return ast.NewCharFactor(ast.BaseFactor{}, charSeq[1 : len(charSeq) - 1]), nil
}
NormalChar <- [^'\\]  // シングルクォートとバックスラッシュ以外の任意の文字
SingleCharEscape <- '\\' [''\\/bfnrt']  // エスケープされた文字

NumberFactor <- '-'? [0-9]+ {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, nil
    }
    return ast.NewNumberFactor(ast.BaseFactor{}, val), nil
}

_ "whitespace" <- [ \n\t\r]*

Comment <- ('#' / ';') Char* (EOL / EOF) {
    return "", nil
}

Char <- [^\n\r]

EOL <- '\n' / '\r' / "\r\n"

EOF <- !.
