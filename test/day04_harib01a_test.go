package test

import (
	"log"
	"os"

	"github.com/HobbyOSs/gosk/internal/ast"
	"github.com/HobbyOSs/gosk/internal/frontend"
	"github.com/HobbyOSs/gosk/internal/gen"
	"github.com/google/go-cmp/cmp"
)

func (s *Day04Suite) TestHarib01a() {
	const naskStatements = `
; naskfunc
; TAB=4

[FORMAT "WCOFF"]				; オブジェクトファイルを作るモード
[INSTRSET "i486p"]				; 486の命令まで使いたいという記述
[BITS 32]						; 32ビットモード用の機械語を作らせる
[FILE "naskfunc.nas"]			; ソースファイル名情報

		GLOBAL	_io_hlt,_write_mem8

[SECTION .text]

_io_hlt:	; void io_hlt(void);
		HLT
		RET

_write_mem8:	; void write_mem8(int addr, int data);
		MOV		ECX,[ESP+4]		; [ESP+4]にaddrが入っているのでそれをECXに読み込む
		MOV		AL,[ESP+8]		; [ESP+8]にdataが入っているのでそれをALに読み込む
		MOV		[ECX],AL
		RET
`
	// Parse
	pt, err := gen.Parse("naskfunc.nas", []byte(naskStatements))
	s.Require().NoError(err)
	prog, ok := pt.(ast.Prog)
	s.Require().True(ok, "Parsed result is not ast.Prog")

	// Create temp file
	temp, err := os.CreateTemp("", "harib01a_*.img")
	s.Require().NoError(err)
	defer os.Remove(temp.Name()) // clean up

	// Execute frontend
	_, _ = frontend.Exec(prog, temp.Name()) // Ignore both return values as error is handled by os.Exit within Exec

	// Read actual result from temp file
	actual, err := ReadFileAsBytes(temp.Name()) // Use ReadFileAsBytes from test_helper.go
	s.Require().NoError(err)

	expected := []byte{
		0x4C, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, // PointerToRelocations should be 0x99 (symbol table offset)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x60, 0x2E, 0x64, 0x61, 0x74,
		0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PointerToRawData should be 0
		0x40, 0x00, 0x10, 0xC0, 0x2E, 0x62, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x10, 0xC0, 0xF4, 0xC3, 0x8B, 0x4C, // .text section data starts here (offset 0x8c)
		0x24, 0x04, 0x8A, 0x44, 0x24, 0x08, 0x88, 0x01, 0xC3, 0x2E, 0x66, 0x69, 0x6C, 0x65, 0x00, 0x00, // Symbol table starts here (offset 0x99)
		0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x67, 0x01, 0x6E, 0x61, 0x73, 0x6B, 0x66, // .file aux symbol (naskfunc.nas)
		0x75, 0x6E, 0x63, 0x2E, 0x6E, 0x61, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, // .text symbol
		0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01, 0x0D, // .text aux symbol (Length=0xd)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, // .data symbol
		0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // .data aux symbol (Length=0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x62, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // .bss symbol
		0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // .bss aux symbol (Length=0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x69, 0x6F, 0x5F, 0x68, 0x6C, 0x74, 0x00, 0x00, // _io_hlt symbol (Value=0, Section=1)
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // _write_mem8 symbol (Value=2, Section=1)
		0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x5F, // String table size (0x10 = 16 bytes)
		0x77, 0x72, 0x69, 0x74, 0x65, 0x5F, 0x6D, 0x65, 0x6D, 0x38, 0x00, // String table content (_write_mem8)
	}

	if diff := cmp.Diff(expected, actual); diff != "" {
		log.Printf("error: result mismatch:\n%s", DumpDiff(expected, actual, false))
		s.T().Fail()
	}
	if len(expected) != len(actual) {
		s.T().Fatalf("expected length %d, actual length %d", len(expected), len(actual))
	}
}
